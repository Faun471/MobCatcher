

<!DOCTYPE html>
<html>
  <head>
    <title>
	Commands and Permissions :: MobCatcher Wiki
</title>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="revised" content="2022-06-07T02:30:41 &#43;08">
<meta name="description" content="">



<title>Commands and Permissions :: MobCatcher Wiki</title>

<link rel="shortcut icon" href='/images/favicon.png' type="image/x-icon" />

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.css">

<script src='https://code.jquery.com/jquery-3.5.1.min.js'></script>

<link href='https://fonts.googleapis.com/css?family=Montserrat:400,700' rel="stylesheet">



<link rel="stylesheet" type="text/css" href='/sass/layout.css'>
<link rel="stylesheet" type="text/css" href='/css/style.main.css'>
<link rel="stylesheet" type="text/css" href='/css/style.menu.css'>
<link rel="stylesheet" type="text/css" href='/sass/shortcodes/notice.css'>
<link rel="stylesheet" type="text/css" href='/sass/shortcodes/tabs.css'>
<link rel="stylesheet" type="text/css" href='/sass/shortcodes/panel.css'>
<link rel="stylesheet" type="text/css" href='/sass/shortcodes/columns.css'>
<link rel="stylesheet" type="text/css" href='/sass/shortcodes/children.css'>
<link rel="stylesheet" type="text/css" href='/sass/shortcodes/attachments.css'>
<link rel="stylesheet" type="text/css" href='/sass/shortcodes/alert.css'>
<link rel="stylesheet" type="text/css" href='/sass/shortcodes/video.css'>
<link rel="stylesheet" type="text/css" href='/css/docport.css'>

<script src='/js/docport.js'></script>
<script type="text/javascript">
      var baseurl = "";
</script>


<style type="text/css">
article section.page nav.subpages li a {
    color: rgb(76, 130, 226);
}
    article section.page h1:first-of-type span::before {
    color: rgb(182, 175, 166);
    }

    body article {
        background-color: rgb(24, 26, 27);
    }

    body {
        color: rgb(223, 220, 215);
        background-color: rgb(24, 26, 27);
    }

    body header {
        background-color: #552d58;
        border-bottom: 0;
        box-shadow: 0 0 0.2rem rgb(0 0 0 / 10%), 0 0.2rem 0.4rem rgb(0 0 0 / 20%);
        justify-content: space-between;
        align-items: stretch;
        color: #f8f1f8;
    }

    hr {
        border-right-color: initial;
        border-bottom-color: initial;
        border-left-color: initial;
        border-top-color: rgba(140, 130, 115, 0.1);
    }

    article>aside {
        background-color: rgb(24, 26, 27);
    }

    article>aside .menu .dd-item.active {
        line-height: 1rem;
        margin-top: 1rem;
    }

    article>aside .menu .dd-item.active {
        background-color: rgba(129, 68, 133, 0.1);
    }

    article>aside .menu .dd-item.active>a {
        color: rgb(152, 143, 129);
    }

    article>aside .menu .dd-item > a {
        color: rgb(152, 143, 129);
    }

    article section.page h1:first-of-type {
        color: rgb(203, 160, 206);
    }

    body a {
        color: rgba(230, 228, 225, 0.897);
        background-color: transparent;
    }

    body a:hover {
        color: rgb(255, 255, 255);
        text-decoration: white;
    }

    article section.page #ariane ol li a {
        color: rgb(223, 220, 215);
        border-bottom-color: rgb(171, 115, 175);
        padding-bottom: 1px;
        padding-right: 0px;
    }

    article section.page div.jump-to-section {
        color: rgb(203, 160, 206);
    }

    body article section.right-menu>div label {
        border-bottom-color: rgb(99, 52, 102);
        color: rgb(203, 160, 206);
    }

    article section.page #ariane ol li::after {
        color: rgb(223, 220, 215);
    }

    ::-webkit-scrollbar {
        background-color: #202324;
        color: #aba499;
    }

    ::-webkit-scrollbar-corner {
        background-color: #181a1b;
    }

    ::-webkit-scrollbar-thumb {
        background-color: #454a4d;
    }

    ::selection {
        background-color: #004daa !important;
        color: #e8e6e3 !important;
    }

    article section.page div.content a {
        color: #6ab183;
        font-weight: 500;
        text-decoration: underline;
    }

    article section.page div.content table {
        border-color: rgb(55, 60, 62);
        border: none;
    }

    article section.page div.content table td {
        border-color: rgb(55, 60, 62);
        color: rgb(200, 196, 189);
    }

    article section.page div.content table th {
        background-color: rgb(15, 16, 17);
        color: rgb(197, 192, 184);
        border: 0.1px solid rgb(55, 60, 62);
    }

    div.notices>label {
        font-size: 0.7em;
    }

    div.notices.warning> :not(label) {
        box-shadow: rgb(150 112 0) 4px 0px 0px inset;
        background-image: initial;
        background-color: rgba(150, 112, 0, 0.05);
        color: rgb(255, 214, 92) !important;
    }

    article section.page div.content>div.highlight pre code {
        margin-left: 0;
        margin-right: 0;
    }

     
     

    code[class*="language-"],
    pre[class*="language-"] {
        color: #ccc;
        background: none;
        font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
        font-size: 1em;
        text-align: left;
        white-space: pre;
        word-spacing: normal;
        word-break: normal;
        word-wrap: normal;
        line-height: 1.5;

        -moz-tab-size: 4;
        -o-tab-size: 4;
        tab-size: 4;

        -webkit-hyphens: none;
        -moz-hyphens: none;
        -ms-hyphens: none;
        hyphens: none;

    }

     
    pre[class*="language-"] {
        padding: 1em;
        margin: .5em 0;
        overflow: auto;
    }

    :not(pre)>code[class*="language-"],
    pre[class*="language-"] {
        background: #2d2d2d;
    }

     
    :not(pre)>code[class*="language-"] {
        padding: .1em;
        border-radius: .3em;
        white-space: normal;
    }

    .token.comment,
    .token.block-comment,
    .token.prolog,
    .token.doctype,
    .token.cdata {
        color: #999;
    }

    .token.punctuation {
        color: #ccc;
    }

    .token.tag,
    .token.attr-name,
    .token.namespace,
    .token.deleted {
        color: #e2777a;
    }

    .token.function-name {
        color: #6196cc;
    }

    .token.boolean,
    .token.number,
    .token.function {
        color: #f08d49;
    }

    .token.property,
    .token.class-name,
    .token.constant,
    .token.symbol {
        color: #f8c555;
    }

    .token.selector,
    .token.important,
    .token.atrule,
    .token.keyword,
    .token.builtin {
        color: #cc99cd;
    }

    .token.string,
    .token.char,
    .token.attr-value,
    .token.regex,
    .token.variable {
        color: #7ec699;
    }

    .token.operator,
    .token.entity,
    .token.url {
        color: #67cdcc;
    }

    .token.important,
    .token.bold {
        font-weight: bold;
    }

    .token.italic {
        font-style: italic;
    }

    .token.entity {
        cursor: help;
    }

    .token.inserted {
        color: green;
    }

    code {
        background: #2d2d2d;
        font-size: 90%;
        color: #7ec699;
        word-wrap: break-word;
    }

    pre[class*="language-"].line-numbers {
        position: relative;
        padding-left: 3.8em;
        counter-reset: linenumber;
    }

    pre[class*="language-"].line-numbers>code {
        position: relative;
        white-space: inherit;
    }

    .line-numbers .line-numbers-rows {
        position: absolute;
        pointer-events: none;
        top: 0;
        font-size: 100%;
        left: -3.8em;
        width: 3em;
         
        letter-spacing: -1px;
        border-right: 1px solid #999;

        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;

    }

    .line-numbers-rows>span {
        display: block;
        counter-increment: linenumber;
    }

    .line-numbers-rows>span:before {
        content: counter(linenumber);
        color: #999;
        display: block;
        padding-right: 0.8em;
        text-align: right;
    }

    div.code-toolbar {
        position: relative;
    }

    div.code-toolbar>.toolbar {
        position: absolute;
        z-index: 10;
        top: .3em;
        right: .2em;
        transition: opacity 0.3s ease-in-out;
        opacity: 0;
    }

    div.code-toolbar:hover>.toolbar {
        opacity: 1;
    }

     
    div.code-toolbar:focus-within>.toolbar {
        opacity: 1;
    }

    div.code-toolbar>.toolbar>.toolbar-item {
        display: inline-block;
    }

    div.code-toolbar>.toolbar>.toolbar-item>a {
        cursor: pointer;
    }

    div.code-toolbar>.toolbar>.toolbar-item>button {
        background: none;
        border: 0;
        color: inherit;
        font: inherit;
        line-height: normal;
        overflow: visible;
        padding: 0;
        -webkit-user-select: none;
         
        -moz-user-select: none;
        -ms-user-select: none;
    }

    div.code-toolbar>.toolbar>.toolbar-item>a,
    div.code-toolbar>.toolbar>.toolbar-item>button,
    div.code-toolbar>.toolbar>.toolbar-item>span {
        color: #bbb;
        font-size: .8em;
        padding: 0 .5em;
        background: #f5f2f0;
        background: rgba(224, 224, 224, 0.2);
        box-shadow: 0 2px 0 0 rgba(0, 0, 0, 0.2);
        border-radius: .5em;
    }

    div.code-toolbar>.toolbar>.toolbar-item>a:hover,
    div.code-toolbar>.toolbar>.toolbar-item>a:focus,
    div.code-toolbar>.toolbar>.toolbar-item>button:hover,
    div.code-toolbar>.toolbar>.toolbar-item>button:focus,
    div.code-toolbar>.toolbar>.toolbar-item>span:hover,
    div.code-toolbar>.toolbar>.toolbar-item>span:focus {
        color: inherit;
        text-decoration: none;
    }


    .tabs>input[type="radio"]:checked+label {
        color: #fff;
        border-bottom-color: rgb(0, 90, 199);
    }


    .tabs label {
        color: rgba(214, 214, 214, 0.767);
    }

    pre code {
        color: inherit;
    }

    .tabs {
        border: 1px #e9ecef dotted;
        border-radius: 0.25rem;
        overflow: hidden;
        display: flex;
        flex-wrap: wrap;
    }

    div.notices.primary> :not(label) {
        box-shadow: rgb(0 98 204) 4px 0px 0px inset;
        background-image: initial;
        background-color: rgba(0, 98, 204, 0.05);
        color: rgb(112, 190, 255) !important;
    }
</style>


<script>
    

    

    var _self = (typeof window !== 'undefined')
        ? window   
        : (
            (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
                ? self 
                : {}   
        );

    

    var Prism = (function (_self) {

        
        var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
        var uniqueId = 0;

        
        var plainTextGrammar = {};


        var _ = {
            

            manual: _self.Prism && _self.Prism.manual,
            

            disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

            

            util: {
                encode: function encode(tokens) {
                    if (tokens instanceof Token) {
                        return new Token(tokens.type, encode(tokens.content), tokens.alias);
                    } else if (Array.isArray(tokens)) {
                        return tokens.map(encode);
                    } else {
                        return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
                    }
                },

                

                type: function (o) {
                    return Object.prototype.toString.call(o).slice(8, -1);
                },

                

                objId: function (obj) {
                    if (!obj['__id']) {
                        Object.defineProperty(obj, '__id', { value: ++uniqueId });
                    }
                    return obj['__id'];
                },

                

                clone: function deepClone(o, visited) {
                    visited = visited || {};

                    var clone; var id;
                    switch (_.util.type(o)) {
                        case 'Object':
                            id = _.util.objId(o);
                            if (visited[id]) {
                                return visited[id];
                            }
                            clone =   ({});
                            visited[id] = clone;

                            for (var key in o) {
                                if (o.hasOwnProperty(key)) {
                                    clone[key] = deepClone(o[key], visited);
                                }
                            }

                            return   (clone);

                        case 'Array':
                            id = _.util.objId(o);
                            if (visited[id]) {
                                return visited[id];
                            }
                            clone = [];
                            visited[id] = clone;

                            ( ( (o))).forEach(function (v, i) {
                                clone[i] = deepClone(v, visited);
                            });

                            return   (clone);

                        default:
                            return o;
                    }
                },

                

                getLanguage: function (element) {
                    while (element) {
                        var m = lang.exec(element.className);
                        if (m) {
                            return m[1].toLowerCase();
                        }
                        element = element.parentElement;
                    }
                    return 'none';
                },

                

                setLanguage: function (element, language) {
                    
                    
                    element.className = element.className.replace(RegExp(lang, 'gi'), '');

                    
                    
                    element.classList.add('language-' + language);
                    element.classList.add('line-numbers');
                },

                

                currentScript: function () {
                    if (typeof document === 'undefined') {
                        return null;
                    }
                    if ('currentScript' in document && 1 < 2  ) {
                        return   (document.currentScript);
                    }

                    
                    
                    

                    try {
                        throw new Error();
                    } catch (err) {
                        
                        
                        
                        
                        
                        

                        var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
                        if (src) {
                            var scripts = document.getElementsByTagName('script');
                            for (var i in scripts) {
                                if (scripts[i].src == src) {
                                    return scripts[i];
                                }
                            }
                        }
                        return null;
                    }
                },

                

                isActive: function (element, className, defaultActivation) {
                    var no = 'no-' + className;

                    while (element) {
                        var classList = element.classList;
                        if (classList.contains(className)) {
                            return true;
                        }
                        if (classList.contains(no)) {
                            return false;
                        }
                        element = element.parentElement;
                    }
                    return !!defaultActivation;
                }
            },

            

            languages: {
                

                plain: plainTextGrammar,
                plaintext: plainTextGrammar,
                text: plainTextGrammar,
                txt: plainTextGrammar,

                

                extend: function (id, redef) {
                    var lang = _.util.clone(_.languages[id]);

                    for (var key in redef) {
                        lang[key] = redef[key];
                    }

                    return lang;
                },

                

                insertBefore: function (inside, before, insert, root) {
                    root = root ||   (_.languages);
                    var grammar = root[inside];
                     
                    var ret = {};

                    for (var token in grammar) {
                        if (grammar.hasOwnProperty(token)) {

                            if (token == before) {
                                for (var newToken in insert) {
                                    if (insert.hasOwnProperty(newToken)) {
                                        ret[newToken] = insert[newToken];
                                    }
                                }
                            }

                            
                            if (!insert.hasOwnProperty(token)) {
                                ret[token] = grammar[token];
                            }
                        }
                    }

                    var old = root[inside];
                    root[inside] = ret;

                    
                    _.languages.DFS(_.languages, function (key, value) {
                        if (value === old && key != inside) {
                            this[key] = ret;
                        }
                    });

                    return ret;
                },

                
                DFS: function DFS(o, callback, type, visited) {
                    visited = visited || {};

                    var objId = _.util.objId;

                    for (var i in o) {
                        if (o.hasOwnProperty(i)) {
                            callback.call(o, i, o[i], type || i);

                            var property = o[i];
                            var propertyType = _.util.type(property);

                            if (propertyType === 'Object' && !visited[objId(property)]) {
                                visited[objId(property)] = true;
                                DFS(property, callback, null, visited);
                            } else if (propertyType === 'Array' && !visited[objId(property)]) {
                                visited[objId(property)] = true;
                                DFS(property, callback, i, visited);
                            }
                        }
                    }
                }
            },

            plugins: {},

            

            highlightAll: function (async, callback) {
                _.highlightAllUnder(document, async, callback);
            },

            

            highlightAllUnder: function (container, async, callback) {
                var env = {
                    callback: callback,
                    container: container,
                    selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
                };

                _.hooks.run('before-highlightall', env);

                env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

                _.hooks.run('before-all-elements-highlight', env);

                for (var i = 0, element; (element = env.elements[i++]);) {
                    _.highlightElement(element, async === true, env.callback);
                }
            },

            

            highlightElement: function (element, async, callback) {
                
                var language = _.util.getLanguage(element);
                var grammar = _.languages[language];

                
                _.util.setLanguage(element, language);

                
                var parent = element.parentElement;
                if (parent && parent.nodeName.toLowerCase() === 'pre') {
                    _.util.setLanguage(parent, language);
                }

                var code = element.textContent;

                var env = {
                    element: element,
                    language: language,
                    grammar: grammar,
                    code: code
                };

                function insertHighlightedCode(highlightedCode) {
                    env.highlightedCode = highlightedCode;

                    _.hooks.run('before-insert', env);

                    env.element.innerHTML = env.highlightedCode;

                    _.hooks.run('after-highlight', env);
                    _.hooks.run('complete', env);
                    callback && callback.call(env.element);
                }

                _.hooks.run('before-sanity-check', env);

                
                parent = env.element.parentElement;
                if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
                    parent.setAttribute('tabindex', '0');
                }

                if (!env.code) {
                    _.hooks.run('complete', env);
                    callback && callback.call(env.element);
                    return;
                }

                _.hooks.run('before-highlight', env);

                if (!env.grammar) {
                    insertHighlightedCode(_.util.encode(env.code));
                    return;
                }

                if (async && _self.Worker) {
                    var worker = new Worker(_.filename);

                    worker.onmessage = function (evt) {
                        insertHighlightedCode(evt.data);
                    };

                    worker.postMessage(JSON.stringify({
                        language: env.language,
                        code: env.code,
                        immediateClose: true
                    }));
                } else {
                    insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
                }
            },

            

            highlight: function (text, grammar, language) {
                var env = {
                    code: text,
                    grammar: grammar,
                    language: language
                };
                _.hooks.run('before-tokenize', env);
                if (!env.grammar) {
                    throw new Error('The language "' + env.language + '" has no grammar.');
                }
                env.tokens = _.tokenize(env.code, env.grammar);
                _.hooks.run('after-tokenize', env);
                return Token.stringify(_.util.encode(env.tokens), env.language);
            },

            

            tokenize: function (text, grammar) {
                var rest = grammar.rest;
                if (rest) {
                    for (var token in rest) {
                        grammar[token] = rest[token];
                    }

                    delete grammar.rest;
                }

                var tokenList = new LinkedList();
                addAfter(tokenList, tokenList.head, text);

                matchGrammar(text, tokenList, grammar, tokenList.head, 0);

                return toArray(tokenList);
            },

            

            hooks: {
                all: {},

                

                add: function (name, callback) {
                    var hooks = _.hooks.all;

                    hooks[name] = hooks[name] || [];

                    hooks[name].push(callback);
                },

                

                run: function (name, env) {
                    var callbacks = _.hooks.all[name];

                    if (!callbacks || !callbacks.length) {
                        return;
                    }

                    for (var i = 0, callback; (callback = callbacks[i++]);) {
                        callback(env);
                    }
                }
            },

            Token: Token
        };
        _self.Prism = _;


        
        
        
        

        

        function Token(type, content, alias, matchedStr) {
            

            this.type = type;
            

            this.content = content;
            

            this.alias = alias;
            
            this.length = (matchedStr || '').length | 0;
        }

        


        

        Token.stringify = function stringify(o, language) {
            if (typeof o == 'string') {
                return o;
            }
            if (Array.isArray(o)) {
                var s = '';
                o.forEach(function (e) {
                    s += stringify(e, language);
                });
                return s;
            }

            var env = {
                type: o.type,
                content: stringify(o.content, language),
                tag: 'span',
                classes: ['token', o.type],
                attributes: {},
                language: language
            };

            var aliases = o.alias;
            if (aliases) {
                if (Array.isArray(aliases)) {
                    Array.prototype.push.apply(env.classes, aliases);
                } else {
                    env.classes.push(aliases);
                }
            }

            _.hooks.run('wrap', env);

            var attributes = '';
            for (var name in env.attributes) {
                attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
            }

            return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
        };

        

        function matchPattern(pattern, pos, text, lookbehind) {
            pattern.lastIndex = pos;
            var match = pattern.exec(text);
            if (match && lookbehind && match[1]) {
                
                var lookbehindLength = match[1].length;
                match.index += lookbehindLength;
                match[0] = match[0].slice(lookbehindLength);
            }
            return match;
        }

        

        function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
            for (var token in grammar) {
                if (!grammar.hasOwnProperty(token) || !grammar[token]) {
                    continue;
                }

                var patterns = grammar[token];
                patterns = Array.isArray(patterns) ? patterns : [patterns];

                for (var j = 0; j < patterns.length; ++j) {
                    if (rematch && rematch.cause == token + ',' + j) {
                        return;
                    }

                    var patternObj = patterns[j];
                    var inside = patternObj.inside;
                    var lookbehind = !!patternObj.lookbehind;
                    var greedy = !!patternObj.greedy;
                    var alias = patternObj.alias;

                    if (greedy && !patternObj.pattern.global) {
                        
                        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                        patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
                    }

                     
                    var pattern = patternObj.pattern || patternObj;

                    for ( 
                        var currentNode = startNode.next, pos = startPos;
                        currentNode !== tokenList.tail;
                        pos += currentNode.value.length, currentNode = currentNode.next
                    ) {

                        if (rematch && pos >= rematch.reach) {
                            break;
                        }

                        var str = currentNode.value;

                        if (tokenList.length > text.length) {
                            
                            return;
                        }

                        if (str instanceof Token) {
                            continue;
                        }

                        var removeCount = 1; 
                        var match;

                        if (greedy) {
                            match = matchPattern(pattern, pos, text, lookbehind);
                            if (!match || match.index >= text.length) {
                                break;
                            }

                            var from = match.index;
                            var to = match.index + match[0].length;
                            var p = pos;

                            
                            p += currentNode.value.length;
                            while (from >= p) {
                                currentNode = currentNode.next;
                                p += currentNode.value.length;
                            }
                            
                            p -= currentNode.value.length;
                            pos = p;

                            
                            if (currentNode.value instanceof Token) {
                                continue;
                            }

                            
                            for (
                                var k = currentNode;
                                k !== tokenList.tail && (p < to || typeof k.value === 'string');
                                k = k.next
                            ) {
                                removeCount++;
                                p += k.value.length;
                            }
                            removeCount--;

                            
                            str = text.slice(pos, p);
                            match.index -= pos;
                        } else {
                            match = matchPattern(pattern, 0, str, lookbehind);
                            if (!match) {
                                continue;
                            }
                        }

                        
                        var from = match.index;
                        var matchStr = match[0];
                        var before = str.slice(0, from);
                        var after = str.slice(from + matchStr.length);

                        var reach = pos + str.length;
                        if (rematch && reach > rematch.reach) {
                            rematch.reach = reach;
                        }

                        var removeFrom = currentNode.prev;

                        if (before) {
                            removeFrom = addAfter(tokenList, removeFrom, before);
                            pos += before.length;
                        }

                        removeRange(tokenList, removeFrom, removeCount);

                        var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                        currentNode = addAfter(tokenList, removeFrom, wrapped);

                        if (after) {
                            addAfter(tokenList, currentNode, after);
                        }

                        if (removeCount > 1) {
                            
                            

                             
                            var nestedRematch = {
                                cause: token + ',' + j,
                                reach: reach
                            };
                            matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

                            
                            if (rematch && nestedRematch.reach > rematch.reach) {
                                rematch.reach = nestedRematch.reach;
                            }
                        }
                    }
                }
            }
        }

        


        

        function LinkedList() {
             
            var head = { value: null, prev: null, next: null };
             
            var tail = { value: null, prev: head, next: null };
            head.next = tail;

             
            this.head = head;
             
            this.tail = tail;
            this.length = 0;
        }

        

        function addAfter(list, node, value) {
            
            var next = node.next;

            var newNode = { value: value, prev: node, next: next };
            node.next = newNode;
            next.prev = newNode;
            list.length++;

            return newNode;
        }
        

        function removeRange(list, node, count) {
            var next = node.next;
            for (var i = 0; i < count && next !== list.tail; i++) {
                next = next.next;
            }
            node.next = next;
            next.prev = node;
            list.length -= i;
        }
        

        function toArray(list) {
            var array = [];
            var node = list.head.next;
            while (node !== list.tail) {
                array.push(node.value);
                node = node.next;
            }
            return array;
        }


        if (!_self.document) {
            if (!_self.addEventListener) {
                
                return _;
            }

            if (!_.disableWorkerMessageHandler) {
                
                _self.addEventListener('message', function (evt) {
                    var message = JSON.parse(evt.data);
                    var lang = message.language;
                    var code = message.code;
                    var immediateClose = message.immediateClose;

                    _self.postMessage(_.highlight(code, _.languages[lang], lang));
                    if (immediateClose) {
                        _self.close();
                    }
                }, false);
            }

            return _;
        }

        
        var script = _.util.currentScript();

        if (script) {
            _.filename = script.src;

            if (script.hasAttribute('data-manual')) {
                _.manual = true;
            }
        }

        function highlightAutomaticallyCallback() {
            if (!_.manual) {
                _.highlightAll();
            }
        }

        if (!_.manual) {
            
            
            
            
            
            
            var readyState = document.readyState;
            if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
                document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
            } else {
                if (window.requestAnimationFrame) {
                    window.requestAnimationFrame(highlightAutomaticallyCallback);
                } else {
                    window.setTimeout(highlightAutomaticallyCallback, 16);
                }
            }
        }

        return _;

    }(_self));

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = Prism;
    }

    
    if (typeof global !== 'undefined') {
        global.Prism = Prism;
    }

    

    


    


    


    

    ;
    Prism.languages.markup = {
        'comment': {
            pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
            greedy: true
        },
        'prolog': {
            pattern: /<\?[\s\S]+?\?>/,
            greedy: true
        },
        'doctype': {
            
            pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
            greedy: true,
            inside: {
                'internal-subset': {
                    pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
                    lookbehind: true,
                    greedy: true,
                    inside: null 
                },
                'string': {
                    pattern: /"[^"]*"|'[^']*'/,
                    greedy: true
                },
                'punctuation': /^<!|>$|[[\]]/,
                'doctype-tag': /^DOCTYPE/i,
                'name': /[^\s<>'"]+/
            }
        },
        'cdata': {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            greedy: true
        },
        'tag': {
            pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
            greedy: true,
            inside: {
                'tag': {
                    pattern: /^<\/?[^\s>\/]+/,
                    inside: {
                        'punctuation': /^<\/?/,
                        'namespace': /^[^\s>\/:]+:/
                    }
                },
                'special-attr': [],
                'attr-value': {
                    pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                    inside: {
                        'punctuation': [
                            {
                                pattern: /^=/,
                                alias: 'attr-equals'
                            },
                            {
                                pattern: /^(\s*)["']|["']$/,
                                lookbehind: true
                            }
                        ]
                    }
                },
                'punctuation': /\/?>/,
                'attr-name': {
                    pattern: /[^\s>\/]+/,
                    inside: {
                        'namespace': /^[^\s>\/:]+:/
                    }
                }

            }
        },
        'entity': [
            {
                pattern: /&[\da-z]{1,8};/i,
                alias: 'named-entity'
            },
            /&#x?[\da-f]{1,8};/i
        ]
    };

    Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
        Prism.languages.markup['entity'];
    Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

    
    Prism.hooks.add('wrap', function (env) {

        if (env.type === 'entity') {
            env.attributes['title'] = env.content.replace(/&amp;/, '&');
        }
    });

    Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
        

        value: function addInlined(tagName, lang) {
            var includedCdataInside = {};
            includedCdataInside['language-' + lang] = {
                pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
                lookbehind: true,
                inside: Prism.languages[lang]
            };
            includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

            var inside = {
                'included-cdata': {
                    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                    inside: includedCdataInside
                }
            };
            inside['language-' + lang] = {
                pattern: /[\s\S]+/,
                inside: Prism.languages[lang]
            };

            var def = {};
            def[tagName] = {
                pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
                lookbehind: true,
                greedy: true,
                inside: inside
            };

            Prism.languages.insertBefore('markup', 'cdata', def);
        }
    });
    Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
        

        value: function (attrName, lang) {
            Prism.languages.markup.tag.inside['special-attr'].push({
                pattern: RegExp(
                    /(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
                    'i'
                ),
                lookbehind: true,
                inside: {
                    'attr-name': /^[^\s=]+/,
                    'attr-value': {
                        pattern: /=[\s\S]+/,
                        inside: {
                            'value': {
                                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                                lookbehind: true,
                                alias: [lang, 'language-' + lang],
                                inside: Prism.languages[lang]
                            },
                            'punctuation': [
                                {
                                    pattern: /^=/,
                                    alias: 'attr-equals'
                                },
                                /"|'/
                            ]
                        }
                    }
                }
            });
        }
    });

    Prism.languages.html = Prism.languages.markup;
    Prism.languages.mathml = Prism.languages.markup;
    Prism.languages.svg = Prism.languages.markup;

    Prism.languages.xml = Prism.languages.extend('markup', {});
    Prism.languages.ssml = Prism.languages.xml;
    Prism.languages.atom = Prism.languages.xml;
    Prism.languages.rss = Prism.languages.xml;

    (function (Prism) {

        var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

        Prism.languages.css = {
            'comment': /\/\*[\s\S]*?\*\//,
            'atrule': {
                pattern: RegExp('@[\\w-](?:' + /[^;{\s"']|\s+(?!\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\s*\{))/.source),
                inside: {
                    'rule': /^@[\w-]+/,
                    'selector-function-argument': {
                        pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                        lookbehind: true,
                        alias: 'selector'
                    },
                    'keyword': {
                        pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                        lookbehind: true
                    }
                    
                }
            },
            'url': {
                
                pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
                greedy: true,
                inside: {
                    'function': /^url/i,
                    'punctuation': /^\(|\)$/,
                    'string': {
                        pattern: RegExp('^' + string.source + '$'),
                        alias: 'url'
                    }
                }
            },
            'selector': {
                pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
                lookbehind: true
            },
            'string': {
                pattern: string,
                greedy: true
            },
            'property': {
                pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
                lookbehind: true
            },
            'important': /!important\b/i,
            'function': {
                pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
                lookbehind: true
            },
            'punctuation': /[(){};:,]/
        };

        Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

        var markup = Prism.languages.markup;
        if (markup) {
            markup.tag.addInlined('style', 'css');
            markup.tag.addAttribute('style', 'css');
        }

    }(Prism));

    Prism.languages.clike = {
        'comment': [
            {
                pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                lookbehind: true,
                greedy: true
            },
            {
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true,
                greedy: true
            }
        ],
        'string': {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        'class-name': {
            pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
            lookbehind: true,
            inside: {
                'punctuation': /[.\\]/
            }
        },
        'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
        'boolean': /\b(?:false|true)\b/,
        'function': /\b\w+(?=\()/,
        'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        'punctuation': /[{}[\];(),.:]/
    };

    Prism.languages.javascript = Prism.languages.extend('clike', {
        'class-name': [
            Prism.languages.clike['class-name'],
            {
                pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
                lookbehind: true
            }
        ],
        'keyword': [
            {
                pattern: /((?:^|\})\s*)catch\b/,
                lookbehind: true
            },
            {
                pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
                lookbehind: true
            },
        ],
        
        'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        'number': {
            pattern: RegExp(
                /(^|[^\w$])/.source +
                '(?:' +
                (
                    
                    /NaN|Infinity/.source +
                    '|' +
                    
                    /0[bB][01]+(?:_[01]+)*n?/.source +
                    '|' +
                    
                    /0[oO][0-7]+(?:_[0-7]+)*n?/.source +
                    '|' +
                    
                    /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
                    '|' +
                    
                    /\d+(?:_\d+)*n/.source +
                    '|' +
                    
                    /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
                ) +
                ')' +
                /(?![\w$])/.source
            ),
            lookbehind: true
        },
        'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });

    Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

    Prism.languages.insertBefore('javascript', 'keyword', {
        'regex': {
            pattern: RegExp(
                
                
                /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
                
                
                
                
                /\//.source +
                '(?:' +
                /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
                '|' +
                
                /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
                ')' +
                
                /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
            ),
            lookbehind: true,
            greedy: true,
            inside: {
                'regex-source': {
                    pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                    lookbehind: true,
                    alias: 'language-regex',
                    inside: Prism.languages.regex
                },
                'regex-delimiter': /^\/|\/$/,
                'regex-flags': /^[a-z]+$/,
            }
        },
        
        'function-variable': {
            pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
            alias: 'function'
        },
        'parameter': [
            {
                pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            {
                pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            {
                pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            {
                pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
                lookbehind: true,
                inside: Prism.languages.javascript
            }
        ],
        'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });

    Prism.languages.insertBefore('javascript', 'string', {
        'hashbang': {
            pattern: /^#!.*/,
            greedy: true,
            alias: 'comment'
        },
        'template-string': {
            pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
            greedy: true,
            inside: {
                'template-punctuation': {
                    pattern: /^`|`$/,
                    alias: 'string'
                },
                'interpolation': {
                    pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                    lookbehind: true,
                    inside: {
                        'interpolation-punctuation': {
                            pattern: /^\$\{|\}$/,
                            alias: 'punctuation'
                        },
                        rest: Prism.languages.javascript
                    }
                },
                'string': /[\s\S]+/
            }
        },
        'string-property': {
            pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
            lookbehind: true,
            greedy: true,
            alias: 'property'
        }
    });

    Prism.languages.insertBefore('javascript', 'operator', {
        'literal-property': {
            pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
            lookbehind: true,
            alias: 'property'
        },
    });

    if (Prism.languages.markup) {
        Prism.languages.markup.tag.addInlined('script', 'javascript');

        
        
        Prism.languages.markup.tag.addAttribute(
            /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
            'javascript'
        );
    }

    Prism.languages.js = Prism.languages.javascript;

    (function (Prism) {

        var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;

        
        var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;

        
        var className = {
            pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
            lookbehind: true,
            inside: {
                'namespace': {
                    pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
                    inside: {
                        'punctuation': /\./
                    }
                },
                'punctuation': /\./
            }
        };

        Prism.languages.java = Prism.languages.extend('clike', {
            'string': {
                pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
                lookbehind: true,
                greedy: true
            },
            'class-name': [
                className,
                {
                    
                    
                    pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
                    lookbehind: true,
                    inside: className.inside
                },
                {
                    
                    
                    pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
                    lookbehind: true,
                    inside: className.inside
                }
            ],
            'keyword': keywords,
            'function': [
                Prism.languages.clike.function,
                {
                    pattern: /(::\s*)[a-z_]\w*/,
                    lookbehind: true
                }
            ],
            'number': /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
            'operator': {
                pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
                lookbehind: true
            }
        });

        Prism.languages.insertBefore('java', 'string', {
            'triple-quoted-string': {
                
                pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
                greedy: true,
                alias: 'string'
            },
            'char': {
                pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
                greedy: true
            }
        });

        Prism.languages.insertBefore('java', 'class-name', {
            'annotation': {
                pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
                lookbehind: true,
                alias: 'punctuation'
            },
            'generics': {
                pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
                inside: {
                    'class-name': className,
                    'keyword': keywords,
                    'punctuation': /[<>(),.:]/,
                    'operator': /[?&|]/
                }
            },
            'import': [
                {
                    pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
                    lookbehind: true,
                    inside: {
                        'namespace': className.inside.namespace,
                        'punctuation': /\./,
                        'operator': /\*/,
                        'class-name': /\w+/
                    }
                },
                {
                    pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
                    lookbehind: true,
                    alias: 'static',
                    inside: {
                        'namespace': className.inside.namespace,
                        'static': /\b\w+$/,
                        'punctuation': /\./,
                        'operator': /\*/,
                        'class-name': /\w+/
                    }
                }
            ],
            'namespace': {
                pattern: RegExp(
                    /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/
                        .source.replace(/<keyword>/g, function () { return keywords.source; })),
                lookbehind: true,
                inside: {
                    'punctuation': /\./,
                }
            }
        });
    }(Prism));

    (function (Prism) {

        
        var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;

        

        function createInline(pattern) {
            pattern = pattern.replace(/<inner>/g, function () { return inner; });
            return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + '(?:' + pattern + ')');
        }


        var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
        var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function () { return tableCell; });
        var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;


        Prism.languages.markdown = Prism.languages.extend('markup', {});
        Prism.languages.insertBefore('markdown', 'prolog', {
            'front-matter-block': {
                pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
                lookbehind: true,
                greedy: true,
                inside: {
                    'punctuation': /^---|---$/,
                    'front-matter': {
                        pattern: /\S+(?:\s+\S+)*/,
                        alias: ['yaml', 'language-yaml'],
                        inside: Prism.languages.yaml
                    }
                }
            },
            'blockquote': {
                
                pattern: /^>(?:[\t ]*>)*/m,
                alias: 'punctuation'
            },
            'table': {
                pattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),
                inside: {
                    'table-data-rows': {
                        pattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),
                        lookbehind: true,
                        inside: {
                            'table-data': {
                                pattern: RegExp(tableCell),
                                inside: Prism.languages.markdown
                            },
                            'punctuation': /\|/
                        }
                    },
                    'table-line': {
                        pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),
                        lookbehind: true,
                        inside: {
                            'punctuation': /\||:?-{3,}:?/
                        }
                    },
                    'table-header-row': {
                        pattern: RegExp('^' + tableRow + '$'),
                        inside: {
                            'table-header': {
                                pattern: RegExp(tableCell),
                                alias: 'important',
                                inside: Prism.languages.markdown
                            },
                            'punctuation': /\|/
                        }
                    }
                }
            },
            'code': [
                {
                    
                    pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
                    lookbehind: true,
                    alias: 'keyword'
                },
                {
                    
                    
                    
                    pattern: /^```[\s\S]*?^```$/m,
                    greedy: true,
                    inside: {
                        'code-block': {
                            pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
                            lookbehind: true
                        },
                        'code-language': {
                            pattern: /^(```).+/,
                            lookbehind: true
                        },
                        'punctuation': /```/
                    }
                }
            ],
            'title': [
                {
                    
                    

                    
                    
                    pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
                    alias: 'important',
                    inside: {
                        punctuation: /==+$|--+$/
                    }
                },
                {
                    
                    
                    pattern: /(^\s*)#.+/m,
                    lookbehind: true,
                    alias: 'important',
                    inside: {
                        punctuation: /^#+|#+$/
                    }
                }
            ],
            'hr': {
                
                
                
                
                pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
                lookbehind: true,
                alias: 'punctuation'
            },
            'list': {
                
                
                
                
                pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
                lookbehind: true,
                alias: 'punctuation'
            },
            'url-reference': {
                
                
                
                
                pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
                inside: {
                    'variable': {
                        pattern: /^(!?\[)[^\]]+/,
                        lookbehind: true
                    },
                    'string': /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
                    'punctuation': /^[\[\]!:]|[<>]/
                },
                alias: 'url'
            },
            'bold': {
                
                

                
                pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
                lookbehind: true,
                greedy: true,
                inside: {
                    'content': {
                        pattern: /(^..)[\s\S]+(?=..$)/,
                        lookbehind: true,
                        inside: {} 
                    },
                    'punctuation': /\*\*|__/
                }
            },
            'italic': {
                
                

                
                pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
                lookbehind: true,
                greedy: true,
                inside: {
                    'content': {
                        pattern: /(^.)[\s\S]+(?=.$)/,
                        lookbehind: true,
                        inside: {} 
                    },
                    'punctuation': /[*_]/
                }
            },
            'strike': {
                
                
                
                pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
                lookbehind: true,
                greedy: true,
                inside: {
                    'content': {
                        pattern: /(^~~?)[\s\S]+(?=\1$)/,
                        lookbehind: true,
                        inside: {} 
                    },
                    'punctuation': /~~?/
                }
            },
            'code-snippet': {
                
                
                pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
                lookbehind: true,
                greedy: true,
                alias: ['code', 'keyword']
            },
            'url': {
                
                
                
                pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
                lookbehind: true,
                greedy: true,
                inside: {
                    'operator': /^!/,
                    'content': {
                        pattern: /(^\[)[^\]]+(?=\])/,
                        lookbehind: true,
                        inside: {} 
                    },
                    'variable': {
                        pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
                        lookbehind: true
                    },
                    'url': {
                        pattern: /(^\]\()[^\s)]+/,
                        lookbehind: true
                    },
                    'string': {
                        pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
                        lookbehind: true
                    }
                }
            }
        });

        ['url', 'bold', 'italic', 'strike'].forEach(function (token) {
            ['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {
                if (token !== inside) {
                    Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];
                }
            });
        });

        Prism.hooks.add('after-tokenize', function (env) {
            if (env.language !== 'markdown' && env.language !== 'md') {
                return;
            }

            function walkTokens(tokens) {
                if (!tokens || typeof tokens === 'string') {
                    return;
                }

                for (var i = 0, l = tokens.length; i < l; i++) {
                    var token = tokens[i];

                    if (token.type !== 'code') {
                        walkTokens(token.content);
                        continue;
                    }

                    


                    var codeLang = token.content[1];
                    var codeBlock = token.content[3];

                    if (codeLang && codeBlock &&
                        codeLang.type === 'code-language' && codeBlock.type === 'code-block' &&
                        typeof codeLang.content === 'string') {

                        

                        
                        var lang = codeLang.content.replace(/\b#/g, 'sharp').replace(/\b\+\+/g, 'pp');
                        
                        lang = (/[a-z][\w-]*/i.exec(lang) || [''])[0].toLowerCase();
                        var alias = 'language-' + lang;

                        
                        if (!codeBlock.alias) {
                            codeBlock.alias = [alias];
                        } else if (typeof codeBlock.alias === 'string') {
                            codeBlock.alias = [codeBlock.alias, alias];
                        } else {
                            codeBlock.alias.push(alias);
                        }
                    }
                }
            }

            walkTokens(env.tokens);
        });

        Prism.hooks.add('wrap', function (env) {
            if (env.type !== 'code-block') {
                return;
            }

            var codeLang = '';
            for (var i = 0, l = env.classes.length; i < l; i++) {
                var cls = env.classes[i];
                var match = /language-(.+)/.exec(cls);
                if (match) {
                    codeLang = match[1];
                    break;
                }
            }

            var grammar = Prism.languages[codeLang];

            if (!grammar) {
                if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {
                    var id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);
                    env.attributes['id'] = id;

                    Prism.plugins.autoloader.loadLanguages(codeLang, function () {
                        var ele = document.getElementById(id);
                        if (ele) {
                            ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);
                        }
                    });
                }
            } else {
                env.content = Prism.highlight(textContent(env.content), grammar, codeLang);
            }
        });

        var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');

        

        var KNOWN_ENTITY_NAMES = {
            'amp': '&',
            'lt': '<',
            'gt': '>',
            'quot': '"',
        };

        
        var fromCodePoint = String.fromCodePoint || String.fromCharCode;

        

        function textContent(html) {
            
            var text = html.replace(tagPattern, '');

            
            text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function (m, code) {
                code = code.toLowerCase();

                if (code[0] === '#') {
                    var value;
                    if (code[1] === 'x') {
                        value = parseInt(code.slice(2), 16);
                    } else {
                        value = Number(code.slice(1));
                    }

                    return fromCodePoint(value);
                } else {
                    var known = KNOWN_ENTITY_NAMES[code];
                    if (known) {
                        return known;
                    }

                    
                    return m;
                }
            });

            return text;
        }

        Prism.languages.md = Prism.languages.markdown;

    }(Prism));

    (function (Prism) {

        
        
        var anchorOrAlias = /[*&][^\s[\]{},]+/;
        
        var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
        
        var properties = '(?:' + tag.source + '(?:[ \t]+' + anchorOrAlias.source + ')?|'
            + anchorOrAlias.source + '(?:[ \t]+' + tag.source + ')?)';
        
        
        
        var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source
            .replace(/<PLAIN>/g, function () { return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source; });
        var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;

        

        function createValuePattern(value, flags) {
            flags = (flags || '').replace(/m/g, '') + 'm'; 
            var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source
                .replace(/<<prop>>/g, function () { return properties; }).replace(/<<value>>/g, function () { return value; });
            return RegExp(pattern, flags);
        }

        Prism.languages.yaml = {
            'scalar': {
                pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source
                    .replace(/<<prop>>/g, function () { return properties; })),
                lookbehind: true,
                alias: 'string'
            },
            'comment': /#.*/,
            'key': {
                pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source
                    .replace(/<<prop>>/g, function () { return properties; })
                    .replace(/<<key>>/g, function () { return '(?:' + plainKey + '|' + string + ')'; })),
                lookbehind: true,
                greedy: true,
                alias: 'atrule'
            },
            'directive': {
                pattern: /(^[ \t]*)%.+/m,
                lookbehind: true,
                alias: 'important'
            },
            'datetime': {
                pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
                lookbehind: true,
                alias: 'number'
            },
            'boolean': {
                pattern: createValuePattern(/false|true/.source, 'i'),
                lookbehind: true,
                alias: 'important'
            },
            'null': {
                pattern: createValuePattern(/null|~/.source, 'i'),
                lookbehind: true,
                alias: 'important'
            },
            'string': {
                pattern: createValuePattern(string),
                lookbehind: true,
                greedy: true
            },
            'number': {
                pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, 'i'),
                lookbehind: true
            },
            'tag': tag,
            'important': anchorOrAlias,
            'punctuation': /---|[:[\]{}\-,|>?]|\.\.\./
        };

        Prism.languages.yml = Prism.languages.yaml;

    }(Prism));

    (function () {

        if (typeof Prism === 'undefined' || typeof document === 'undefined') {
            return;
        }

        

        var PLUGIN_NAME = 'line-numbers';

        

        var NEW_LINE_EXP = /\n(?!$)/g;


        

        var config = Prism.plugins.lineNumbers = {
            

            getLine: function (element, number) {
                if (element.tagName !== 'PRE' || !element.classList.contains(PLUGIN_NAME)) {
                    return;
                }

                var lineNumberRows = element.querySelector('.line-numbers-rows');
                if (!lineNumberRows) {
                    return;
                }
                var lineNumberStart = parseInt(element.getAttribute('data-start'), 10) || 1;
                var lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);

                if (number < lineNumberStart) {
                    number = lineNumberStart;
                }
                if (number > lineNumberEnd) {
                    number = lineNumberEnd;
                }

                var lineIndex = number - lineNumberStart;

                return lineNumberRows.children[lineIndex];
            },

            

            resize: function (element) {
                resizeElements([element]);
            },

            

            assumeViewportIndependence: true
        };

        

        function resizeElements(elements) {
            elements = elements.filter(function (e) {
                var codeStyles = getStyles(e);
                var whiteSpace = codeStyles['white-space'];
                return whiteSpace === 'pre-wrap' || whiteSpace === 'pre-line';
            });

            if (elements.length == 0) {
                return;
            }

            var infos = elements.map(function (element) {
                var codeElement = element.querySelector('code');
                var lineNumbersWrapper = element.querySelector('.line-numbers-rows');
                if (!codeElement || !lineNumbersWrapper) {
                    return undefined;
                }

                 
                var lineNumberSizer = element.querySelector('.line-numbers-sizer');
                var codeLines = codeElement.textContent.split(NEW_LINE_EXP);

                if (!lineNumberSizer) {
                    lineNumberSizer = document.createElement('span');
                    lineNumberSizer.className = 'line-numbers-sizer';

                    codeElement.appendChild(lineNumberSizer);
                }

                lineNumberSizer.innerHTML = '0';
                lineNumberSizer.style.display = 'block';

                var oneLinerHeight = lineNumberSizer.getBoundingClientRect().height;
                lineNumberSizer.innerHTML = '';

                return {
                    element: element,
                    lines: codeLines,
                    lineHeights: [],
                    oneLinerHeight: oneLinerHeight,
                    sizer: lineNumberSizer,
                };
            }).filter(Boolean);

            infos.forEach(function (info) {
                var lineNumberSizer = info.sizer;
                var lines = info.lines;
                var lineHeights = info.lineHeights;
                var oneLinerHeight = info.oneLinerHeight;

                lineHeights[lines.length - 1] = undefined;
                lines.forEach(function (line, index) {
                    if (line && line.length > 1) {
                        var e = lineNumberSizer.appendChild(document.createElement('span'));
                        e.style.display = 'block';
                        e.textContent = line;
                    } else {
                        lineHeights[index] = oneLinerHeight;
                    }
                });
            });

            infos.forEach(function (info) {
                var lineNumberSizer = info.sizer;
                var lineHeights = info.lineHeights;

                var childIndex = 0;
                for (var i = 0; i < lineHeights.length; i++) {
                    if (lineHeights[i] === undefined) {
                        lineHeights[i] = lineNumberSizer.children[childIndex++].getBoundingClientRect().height;
                    }
                }
            });

            infos.forEach(function (info) {
                var lineNumberSizer = info.sizer;
                var wrapper = info.element.querySelector('.line-numbers-rows');

                lineNumberSizer.style.display = 'none';
                lineNumberSizer.innerHTML = '';

                info.lineHeights.forEach(function (height, lineNumber) {
                    wrapper.children[lineNumber].style.height = height + 'px';
                });
            });
        }

        

        function getStyles(element) {
            if (!element) {
                return null;
            }

            return window.getComputedStyle ? getComputedStyle(element) : (element.currentStyle || null);
        }

        var lastWidth = undefined;
        window.addEventListener('resize', function () {
            if (config.assumeViewportIndependence && lastWidth === window.innerWidth) {
                return;
            }
            lastWidth = window.innerWidth;

            resizeElements(Array.prototype.slice.call(document.querySelectorAll('pre.' + PLUGIN_NAME)));
        });

        Prism.hooks.add('complete', function (env) {
            if (!env.code) {
                return;
            }

            var code =   (env.element);
            var pre =   (code.parentNode);

            
            if (!pre || !/pre/i.test(pre.nodeName)) {
                return;
            }

            
            if (code.querySelector('.line-numbers-rows')) {
                return;
            }

            
            if (!Prism.util.isActive(code, PLUGIN_NAME)) {
                return;
            }

            
            code.classList.remove(PLUGIN_NAME);
            
            pre.classList.add(PLUGIN_NAME);

            var match = env.code.match(NEW_LINE_EXP);
            var linesNum = match ? match.length + 1 : 1;
            var lineNumbersWrapper;

            var lines = new Array(linesNum + 1).join('<span></span>');

            lineNumbersWrapper = document.createElement('span');
            lineNumbersWrapper.setAttribute('aria-hidden', 'true');
            lineNumbersWrapper.className = 'line-numbers-rows';
            lineNumbersWrapper.innerHTML = lines;

            if (pre.hasAttribute('data-start')) {
                pre.style.counterReset = 'linenumber ' + (parseInt(pre.getAttribute('data-start'), 10) - 1);
            }

            env.element.appendChild(lineNumbersWrapper);

            resizeElements([pre]);

            Prism.hooks.run('line-numbers', env);
        });

        Prism.hooks.add('line-numbers', function (env) {
            env.plugins = env.plugins || {};
            env.plugins.lineNumbers = true;
        });

    }());

    (function () {

        if (typeof Prism === 'undefined' || typeof document === 'undefined') {
            return;
        }

        var callbacks = [];
        var map = {};
        var noop = function () { };

        Prism.plugins.toolbar = {};

        


        

        var registerButton = Prism.plugins.toolbar.registerButton = function (key, opts) {
            var callback;

            if (typeof opts === 'function') {
                callback = opts;
            } else {
                callback = function (env) {
                    var element;

                    if (typeof opts.onClick === 'function') {
                        element = document.createElement('button');
                        element.type = 'button';
                        element.addEventListener('click', function () {
                            opts.onClick.call(this, env);
                        });
                    } else if (typeof opts.url === 'string') {
                        element = document.createElement('a');
                        element.href = opts.url;
                    } else {
                        element = document.createElement('span');
                    }

                    if (opts.className) {
                        element.classList.add(opts.className);
                    }

                    element.textContent = opts.text;

                    return element;
                };
            }

            if (key in map) {
                console.warn('There is a button with the key "' + key + '" registered already.');
                return;
            }

            callbacks.push(map[key] = callback);
        };

        

        function getOrder(element) {
            while (element) {
                var order = element.getAttribute('data-toolbar-order');
                if (order != null) {
                    order = order.trim();
                    if (order.length) {
                        return order.split(/\s*,\s*/g);
                    } else {
                        return [];
                    }
                }
                element = element.parentElement;
            }
        }

        

        var hook = Prism.plugins.toolbar.hook = function (env) {
            
            var pre = env.element.parentNode;
            if (!pre || !/pre/i.test(pre.nodeName)) {
                return;
            }

            
            if (pre.parentNode.classList.contains('code-toolbar')) {
                return;
            }

            
            var wrapper = document.createElement('div');
            wrapper.classList.add('code-toolbar');
            pre.parentNode.insertBefore(wrapper, pre);
            wrapper.appendChild(pre);

            
            var toolbar = document.createElement('div');
            toolbar.classList.add('toolbar');

            
            var elementCallbacks = callbacks;
            var order = getOrder(env.element);
            if (order) {
                elementCallbacks = order.map(function (key) {
                    return map[key] || noop;
                });
            }

            elementCallbacks.forEach(function (callback) {
                var element = callback(env);

                if (!element) {
                    return;
                }

                var item = document.createElement('div');
                item.classList.add('toolbar-item');

                item.appendChild(element);
                toolbar.appendChild(item);
            });

            
            wrapper.appendChild(toolbar);
        };

        registerButton('label', function (env) {
            var pre = env.element.parentNode;
            if (!pre || !/pre/i.test(pre.nodeName)) {
                return;
            }

            if (!pre.hasAttribute('data-label')) {
                return;
            }

            var element; var template;
            var text = pre.getAttribute('data-label');
            try {
                
                template = document.querySelector('template#' + text);
            } catch (e) {   }

            if (template) {
                element = template.content;
            } else {
                if (pre.hasAttribute('data-url')) {
                    element = document.createElement('a');
                    element.href = pre.getAttribute('data-url');
                } else {
                    element = document.createElement('span');
                }

                element.textContent = text;
            }

            return element;
        });

        

        Prism.hooks.add('complete', hook);
    }());

    (function () {

        if (typeof Prism === 'undefined' || typeof document === 'undefined') {
            return;
        }

        if (!Prism.plugins.toolbar) {
            console.warn('Show Languages plugin loaded before Toolbar plugin.');

            return;
        }

         

        
        var Languages =  {
            "none": "Plain text",
            "plain": "Plain text",
            "plaintext": "Plain text",
            "text": "Plain text",
            "txt": "Plain text",
            "html": "HTML",
            "xml": "XML",
            "svg": "SVG",
            "mathml": "MathML",
            "ssml": "SSML",
            "rss": "RSS",
            "css": "CSS",
            "clike": "C-like",
            "js": "JavaScript",
            "abap": "ABAP",
            "abnf": "ABNF",
            "al": "AL",
            "antlr4": "ANTLR4",
            "g4": "ANTLR4",
            "apacheconf": "Apache Configuration",
            "apl": "APL",
            "aql": "AQL",
            "ino": "Arduino",
            "arff": "ARFF",
            "armasm": "ARM Assembly",
            "arm-asm": "ARM Assembly",
            "art": "Arturo",
            "asciidoc": "AsciiDoc",
            "adoc": "AsciiDoc",
            "aspnet": "ASP.NET (C#)",
            "asm6502": "6502 Assembly",
            "asmatmel": "Atmel AVR Assembly",
            "autohotkey": "AutoHotkey",
            "autoit": "AutoIt",
            "avisynth": "AviSynth",
            "avs": "AviSynth",
            "avro-idl": "Avro IDL",
            "avdl": "Avro IDL",
            "awk": "AWK",
            "gawk": "GAWK",
            "basic": "BASIC",
            "bbcode": "BBcode",
            "bnf": "BNF",
            "rbnf": "RBNF",
            "bsl": "BSL (1C:Enterprise)",
            "oscript": "OneScript",
            "csharp": "C#",
            "cs": "C#",
            "dotnet": "C#",
            "cpp": "C++",
            "cfscript": "CFScript",
            "cfc": "CFScript",
            "cil": "CIL",
            "cmake": "CMake",
            "cobol": "COBOL",
            "coffee": "CoffeeScript",
            "conc": "Concurnas",
            "csp": "Content-Security-Policy",
            "css-extras": "CSS Extras",
            "csv": "CSV",
            "cue": "CUE",
            "dataweave": "DataWeave",
            "dax": "DAX",
            "django": "Django/Jinja2",
            "jinja2": "Django/Jinja2",
            "dns-zone-file": "DNS zone file",
            "dns-zone": "DNS zone file",
            "dockerfile": "Docker",
            "dot": "DOT (Graphviz)",
            "gv": "DOT (Graphviz)",
            "ebnf": "EBNF",
            "editorconfig": "EditorConfig",
            "ejs": "EJS",
            "etlua": "Embedded Lua templating",
            "erb": "ERB",
            "excel-formula": "Excel Formula",
            "xlsx": "Excel Formula",
            "xls": "Excel Formula",
            "fsharp": "F#",
            "firestore-security-rules": "Firestore security rules",
            "ftl": "FreeMarker Template Language",
            "gml": "GameMaker Language",
            "gamemakerlanguage": "GameMaker Language",
            "gap": "GAP (CAS)",
            "gcode": "G-code",
            "gdscript": "GDScript",
            "gedcom": "GEDCOM",
            "gettext": "gettext",
            "po": "gettext",
            "glsl": "GLSL",
            "gn": "GN",
            "gni": "GN",
            "linker-script": "GNU Linker Script",
            "ld": "GNU Linker Script",
            "go-module": "Go module",
            "go-mod": "Go module",
            "graphql": "GraphQL",
            "hbs": "Handlebars",
            "hs": "Haskell",
            "hcl": "HCL",
            "hlsl": "HLSL",
            "http": "HTTP",
            "hpkp": "HTTP Public-Key-Pins",
            "hsts": "HTTP Strict-Transport-Security",
            "ichigojam": "IchigoJam",
            "icu-message-format": "ICU Message Format",
            "idr": "Idris",
            "ignore": ".ignore",
            "gitignore": ".gitignore",
            "hgignore": ".hgignore",
            "npmignore": ".npmignore",
            "inform7": "Inform 7",
            "javadoc": "JavaDoc",
            "javadoclike": "JavaDoc-like",
            "javastacktrace": "Java stack trace",
            "jq": "JQ",
            "jsdoc": "JSDoc",
            "js-extras": "JS Extras",
            "json": "JSON",
            "webmanifest": "Web App Manifest",
            "json5": "JSON5",
            "jsonp": "JSONP",
            "jsstacktrace": "JS stack trace",
            "js-templates": "JS Templates",
            "keepalived": "Keepalived Configure",
            "kts": "Kotlin Script",
            "kt": "Kotlin",
            "kumir": "KuMir ()",
            "kum": "KuMir ()",
            "latex": "LaTeX",
            "tex": "TeX",
            "context": "ConTeXt",
            "lilypond": "LilyPond",
            "ly": "LilyPond",
            "emacs": "Lisp",
            "elisp": "Lisp",
            "emacs-lisp": "Lisp",
            "llvm": "LLVM IR",
            "log": "Log file",
            "lolcode": "LOLCODE",
            "magma": "Magma (CAS)",
            "md": "Markdown",
            "markup-templating": "Markup templating",
            "matlab": "MATLAB",
            "maxscript": "MAXScript",
            "mel": "MEL",
            "mongodb": "MongoDB",
            "moon": "MoonScript",
            "n1ql": "N1QL",
            "n4js": "N4JS",
            "n4jsd": "N4JS",
            "nand2tetris-hdl": "Nand To Tetris HDL",
            "naniscript": "Naninovel Script",
            "nani": "Naninovel Script",
            "nasm": "NASM",
            "neon": "NEON",
            "nginx": "nginx",
            "nsis": "NSIS",
            "objectivec": "Objective-C",
            "objc": "Objective-C",
            "ocaml": "OCaml",
            "opencl": "OpenCL",
            "openqasm": "OpenQasm",
            "qasm": "OpenQasm",
            "parigp": "PARI/GP",
            "objectpascal": "Object Pascal",
            "psl": "PATROL Scripting Language",
            "pcaxis": "PC-Axis",
            "px": "PC-Axis",
            "peoplecode": "PeopleCode",
            "pcode": "PeopleCode",
            "php": "PHP",
            "phpdoc": "PHPDoc",
            "php-extras": "PHP Extras",
            "plant-uml": "PlantUML",
            "plantuml": "PlantUML",
            "plsql": "PL/SQL",
            "powerquery": "PowerQuery",
            "pq": "PowerQuery",
            "mscript": "PowerQuery",
            "powershell": "PowerShell",
            "promql": "PromQL",
            "properties": ".properties",
            "protobuf": "Protocol Buffers",
            "purebasic": "PureBasic",
            "pbfasm": "PureBasic",
            "purs": "PureScript",
            "py": "Python",
            "qsharp": "Q#",
            "qs": "Q#",
            "q": "Q (kdb+ database)",
            "qml": "QML",
            "rkt": "Racket",
            "cshtml": "Razor C#",
            "razor": "Razor C#",
            "jsx": "React JSX",
            "tsx": "React TSX",
            "renpy": "Ren'py",
            "rpy": "Ren'py",
            "res": "ReScript",
            "rest": "reST (reStructuredText)",
            "robotframework": "Robot Framework",
            "robot": "Robot Framework",
            "rb": "Ruby",
            "sas": "SAS",
            "sass": "Sass (Sass)",
            "scss": "Sass (Scss)",
            "shell-session": "Shell session",
            "sh-session": "Shell session",
            "shellsession": "Shell session",
            "sml": "SML",
            "smlnj": "SML/NJ",
            "solidity": "Solidity (Ethereum)",
            "sol": "Solidity (Ethereum)",
            "solution-file": "Solution file",
            "sln": "Solution file",
            "soy": "Soy (Closure Template)",
            "sparql": "SPARQL",
            "rq": "SPARQL",
            "splunk-spl": "Splunk SPL",
            "sqf": "SQF: Status Quo Function (Arma 3)",
            "sql": "SQL",
            "stata": "Stata Ado",
            "iecst": "Structured Text (IEC 61131-3)",
            "supercollider": "SuperCollider",
            "sclang": "SuperCollider",
            "systemd": "Systemd configuration file",
            "t4-templating": "T4 templating",
            "t4-cs": "T4 Text Templates (C#)",
            "t4": "T4 Text Templates (C#)",
            "t4-vb": "T4 Text Templates (VB)",
            "tap": "TAP",
            "tt2": "Template Toolkit 2",
            "toml": "TOML",
            "trickle": "trickle",
            "troy": "troy",
            "trig": "TriG",
            "ts": "TypeScript",
            "tsconfig": "TSConfig",
            "uscript": "UnrealScript",
            "uc": "UnrealScript",
            "uorazor": "UO Razor Script",
            "uri": "URI",
            "url": "URL",
            "vbnet": "VB.Net",
            "vhdl": "VHDL",
            "vim": "vim",
            "visual-basic": "Visual Basic",
            "vba": "VBA",
            "vb": "Visual Basic",
            "wasm": "WebAssembly",
            "web-idl": "Web IDL",
            "webidl": "Web IDL",
            "wgsl": "WGSL",
            "wiki": "Wiki markup",
            "wolfram": "Wolfram language",
            "nb": "Mathematica Notebook",
            "wl": "Wolfram language",
            "xeoracube": "XeoraCube",
            "xml-doc": "XML doc (.net)",
            "xojo": "Xojo (REALbasic)",
            "xquery": "XQuery",
            "yaml": "YAML",
            "yml": "YAML",
            "yang": "YANG"
        } ;

         

        Prism.plugins.toolbar.registerButton('show-language', function (env) {
            var pre = env.element.parentNode;
            if (!pre || !/pre/i.test(pre.nodeName)) {
                return;
            }

            

            function guessTitle(id) {
                if (!id) {
                    return id;
                }
                return (id.substring(0, 1).toUpperCase() + id.substring(1)).replace(/s(?=cript)/, 'S');
            }

            var language = pre.getAttribute('data-language') || Languages[env.language] || guessTitle(env.language);

            if (!language) {
                return;
            }
            var element = document.createElement('span');
            element.textContent = language;

            return element;
        });

    }());

    (function () {

        if (typeof Prism === 'undefined') {
            return;
        }

        Prism.hooks.add('wrap', function (env) {
            if (env.type !== 'keyword') {
                return;
            }
            env.classes.push('keyword-' + env.content);
        });

    }());

    (function () {

        if (typeof Prism === 'undefined' || typeof document === 'undefined') {
            return;
        }

        if (!Prism.plugins.toolbar) {
            console.warn('Copy to Clipboard plugin loaded before Toolbar plugin.');

            return;
        }

        

        function registerClipboard(element, copyInfo) {
            element.addEventListener('click', function () {
                copyTextToClipboard(copyInfo);
            });
        }

        

         
        function fallbackCopyTextToClipboard(copyInfo) {
            var textArea = document.createElement('textarea');
            textArea.value = copyInfo.getText();

            
            textArea.style.top = '0';
            textArea.style.left = '0';
            textArea.style.position = 'fixed';

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                var successful = document.execCommand('copy');
                setTimeout(function () {
                    if (successful) {
                        copyInfo.success();
                    } else {
                        copyInfo.error();
                    }
                }, 1);
            } catch (err) {
                setTimeout(function () {
                    copyInfo.error(err);
                }, 1);
            }

            document.body.removeChild(textArea);
        }
         
        function copyTextToClipboard(copyInfo) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(copyInfo.getText()).then(copyInfo.success, function () {
                    
                    fallbackCopyTextToClipboard(copyInfo);
                });
            } else {
                fallbackCopyTextToClipboard(copyInfo);
            }
        }

        

        function selectElementText(element) {
            
            window.getSelection().selectAllChildren(element);
        }

        

        function getSettings(startElement) {
             
            var settings = {
                'copy': 'Copy',
                'copy-error': 'Press Ctrl+C to copy',
                'copy-success': 'Copied!',
                'copy-timeout': 5000
            };

            var prefix = 'data-prismjs-';
            for (var key in settings) {
                var attr = prefix + key;
                var element = startElement;
                while (element && !element.hasAttribute(attr)) {
                    element = element.parentElement;
                }
                if (element) {
                    settings[key] = element.getAttribute(attr);
                }
            }
            return settings;
        }

        Prism.plugins.toolbar.registerButton('copy-to-clipboard', function (env) {
            var element = env.element;

            var settings = getSettings(element);

            var linkCopy = document.createElement('button');
            linkCopy.className = 'copy-to-clipboard-button';
            linkCopy.setAttribute('type', 'button');
            var linkSpan = document.createElement('span');
            linkCopy.appendChild(linkSpan);

            setState('copy');

            registerClipboard(linkCopy, {
                getText: function () {
                    return element.textContent;
                },
                success: function () {
                    setState('copy-success');

                    resetText();
                },
                error: function () {
                    setState('copy-error');

                    setTimeout(function () {
                        selectElementText(element);
                    }, 1);

                    resetText();
                }
            });

            return linkCopy;

            function resetText() {
                setTimeout(function () { setState('copy'); }, settings['copy-timeout']);
            }

             
            function setState(state) {
                linkSpan.textContent = settings[state];
                linkCopy.setAttribute('data-copy-state', state);
            }
        });
    }());



</script>

    
  </head>

  <body data-url="/commands-and-permissions/"

  class="hidefooter ">

<style type="text/css">
  #debug{
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    line-height: 3.5rem;
    margin-bottom: .35rem;
    padding: 0 2rem;
    position: fixed;
    left: 0;      right: 0;     top: 0;
   
    top:0px;
    
    min-height: 150px;

    background-color: white;
    border: 3px solid red;
    z-index: 10000 ;
    word-wrap: all;
    overflow: auto;
  }
</style>
 


    
    
    <header style="">
        <div>
    
    <div class="burger ">
        <a href="javascript:void(0);" style="font-size:15px;" onclick="$('article > aside').toggleClass('responsive')">&#9776;</a>
    </div>
    

    <div>

		
	
			
		
	    	<p><a href="/home"><strong>MobCatcher Wiki</strong></a></p>

	    
	</div>
    <nav class="shortcuts">
            <li class="" role="">
                <a href="https://github.com/Faun471/MobCatcher" target="_blank" rel="noopener">
                  Github
                </a>
            </li>
            <li class="" role="">
                <a href="https://github.com/Faun471/MobCatcher/releases" target="_blank" rel="noopener">
                  Download
                </a>
            </li>
    </nav>

</div>
    </header>
    

    <article>
      
      <aside class="">
        

		
	
			
		
	    	
	    
	<div id="close_menu">
  <a href="javascript:void(0);" style="font-size:15px;" onclick="$('article > aside').toggleClass('responsive')">
      <i class="fa fa-lg fa-times"></i>
  </a>
</div>

<ul class="menu">

    <li data-nav-id="/home/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      <i class="fas fa-chevron-right ddexp"></i>
        
      
          <a href="/home/"> Overview</a>
      
        <ul>
              

    <li data-nav-id="/home/installation/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/home/installation/">Installation</a>
      
        
      
    </li>
        </ul>
    </li>
    

    <li data-nav-id="/commands-and-permissions/" class="dd-item active
        item_level_$level
        ">

      
      
      
      
        
      
          <a href="/commands-and-permissions/"> Commands and Permissions</a>
      
    </li>
    

    <li data-nav-id="/configs/" class="dd-item haschildren
        item_level_$level
        ">

      
      
      
      <i class="fas fa-chevron-right ddexp"></i>
        
      
          <a href="/configs/"> Configuration</a>
      
        <ul>
              

    <li data-nav-id="/configs/config/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/configs/config/">config.yml</a>
      
        
      
    </li>
              

    <li data-nav-id="/configs/messages/" class="dd-item
        item_level_$level
        ">

      
      
      
      
          <a href="/configs/messages/">messages.yml</a>
      
        
      
    </li>
        </ul>
    </li>
    



</ul>

		
	
			
		
	    	
	    
	
      </aside>
      

      <section class="page ">
      
	
		
    
    
    <nav id="ariane" aria-label="breadcrumb">
      <ol class="ariane">
        
  
  	
	<li >
      <a class="text-link" href="">
        Home
      </a>
    </li>
	
  
    <li class="active">
      
        Commands and Permissions
      
    </li>

      </ol>
    </nav>
    
    

    
		
        
		
		
		
		
		
		
		

		
			<h1>Commands and Permissions</h1>
        

		
										
		

		
	

	
	
	<div class="jump-to-section">
		<span onclick="$h = $(this);$h.next('nav').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('nav').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
  			<span class="fas fa-align-right"></span>
  			Jump to Section
  			<i style=";" class="fas fa-chevron-right"></i>
		</span>
		<nav id="TableOfContents"></nav>
	</div>
	
	






	<div class="content">
	    <table>
<thead>
<tr>
<th style="text-align:center">Command</th>
<th style="text-align:center">Permission</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/mobcatcher help</td>
<td style="text-align:center">None</td>
<td style="text-align:center">The plugin&rsquo;s help command.</td>
</tr>
<tr>
<td style="text-align:center">/mobcatcher reload</td>
<td style="text-align:center"><code>mobcatcher.reload</code></td>
<td style="text-align:center">Reloads the plugin.</td>
</tr>
<tr>
<td style="text-align:center">/mobcatcher give &lt;player&gt; &lt;mob-catcher item&gt;</td>
<td style="text-align:center"><code>mobcatcher.give</code></td>
<td style="text-align:center">Gives the mob-catcher item to the specified player.</td>
</tr>
</tbody>
</table>

		</div>






	 
	<div class="chevrons">
		<a class="next" href="/configs/" title="Configuration" style="margin-right: 0px;">
            <div>
                <p>Next page</p>
                <label>Configuration</label>
            </div>
            <i class="fas fa-arrow-right" style="font-size: 1.7em"></i></a>
	</div>
	
	

      </section>

      
      
      <section class="right-menu ">
      
	

		
	
			
		
	    	
	  	
	<div class="TableOfContents">
    <label><i class="fas fa-align-right"></i>&nbsp;&nbsp;What&#39;s on this page</label>
    <nav>
        <ul >
            <li><a href="/commands-and-permissions/">Commands and Permissions</a></li>
        </ul>
    </nav>
    <nav id="TableOfContents"></nav>
</div>

		
	
			
		
	    	
	    
	<div class="Actions">
	<nav>
		<ul>
				
		    
		    
			
		    

    	</ul>
	</nav>
    
</div>

      </section>
      
    </article>
    
    



  </body>
</html>
